<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Defender</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevent zoom on mobile */
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #fff;
        }
        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        p {
            font-size: 18px;
            color: #aaa;
        }
        button {
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 15px 30px;
            font-size: 24px;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px #0f0;
            transition: all 0.2s;
        }
        button:hover {
            background: #0f0;
            color: #000;
        }
    </style>
</head>
<body>

<div id="ui">
    Score: <span id="scoreEl">0</span>
</div>

<div id="start-screen">
    <h1>NEON DEFENDER</h1>
    <p>Mouse to Move â€¢ Click to Shoot</p>
    <br>
    <button id="startBtn">Start Game</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreEl');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('startBtn');

    // Game State
    let gameRunning = false;
    let score = 0;
    let frame = 0;
    let canvasWidth, canvasHeight;
    
    // Inputs
    const mouse = { x: 0, y: 0, down: false };

    // Entities
    let player;
    let projectiles = [];
    let enemies = [];
    let particles = [];
    let powerups = [];

    // Configuration
    const COLORS = {
        player: '#0ff',
        enemy: '#f05',
        bullet: '#ff0',
        bg: '#050505',
        particle: ['#fff', '#ff0', '#f05', '#0ff']
    };

    // --- SETUP ---
    function resize() {
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('mousemove', (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    });
    window.addEventListener('mousedown', () => mouse.down = true);
    window.addEventListener('mouseup', () => mouse.down = false);
    
    // Touch support
    window.addEventListener('touchmove', (e) => {
        e.preventDefault();
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
        mouse.down = true;
    }, {passive: false});
    window.addEventListener('touchend', () => mouse.down = false);

    startBtn.addEventListener('click', startGame);

    // --- CLASSES ---
    class Player {
        constructor() {
            this.x = canvasWidth / 2;
            this.y = canvasHeight - 100;
            this.radius = 20;
            this.color = COLORS.player;
            this.gunLevel = 1;
            this.lastShot = 0;
        }

        draw() {
            ctx.beginPath();
            // Draw a futuristic triangle
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x - this.radius, this.y + this.radius);
            ctx.lineTo(this.x, this.y + this.radius - 10);
            ctx.lineTo(this.x + this.radius, this.y + this.radius);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // Glow effect
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.color;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        update() {
            // Lerp towards mouse x
            this.x += (mouse.x - this.x) * 0.15;

            // Boundaries
            if (this.x < this.radius) this.x = this.radius;
            if (this.x > canvasWidth - this.radius) this.x = canvasWidth - this.radius;

            // Shooting
            if (mouse.down && frame - this.lastShot > (20 - this.gunLevel * 2)) {
                this.shoot();
                this.lastShot = frame;
            }
        }

        shoot() {
            // Simple audio context beep could go here, but keeping it silent for now
            if (this.gunLevel === 1) {
                projectiles.push(new Projectile(this.x, this.y - 20, 0, -15));
            } else if (this.gunLevel >= 2) {
                projectiles.push(new Projectile(this.x - 10, this.y - 10, 0, -15));
                projectiles.push(new Projectile(this.x + 10, this.y - 10, 0, -15));
            }
             if (this.gunLevel >= 3) {
                 // Spread shot
                 projectiles.push(new Projectile(this.x, this.y - 20, -2, -14));
                 projectiles.push(new Projectile(this.x, this.y - 20, 2, -14));
            }
        }
    }

    class Projectile {
        constructor(x, y, vx, vy) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.radius = 4;
            this.color = COLORS.bullet;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
        }
    }

    class Enemy {
        constructor() {
            this.radius = Math.random() * 15 + 15;
            this.x = Math.random() * (canvasWidth - this.radius * 2) + this.radius;
            this.y = -this.radius;
            this.speed = Math.random() * 2 + 1 + (score / 5000); // Speed up as game progresses
            this.color = COLORS.enemy;
            this.hp = Math.floor(this.radius / 10);
            
            // Wobble
            this.angle = 0;
            this.wobbleSpeed = Math.random() * 0.1;
            this.wobbleAmp = Math.random() * 2;
        }

        draw() {
            ctx.beginPath();
            // Draw a jagged shape
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x + this.radius, this.y);
            ctx.lineTo(this.x, this.y + this.radius);
            ctx.lineTo(this.x - this.radius, this.y);
            ctx.closePath();
            
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // Inner Core
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI*2);
            ctx.fillStyle = '#fff';
            ctx.fill();
        }

        update() {
            this.y += this.speed;
            this.x += Math.sin(this.angle) * this.wobbleAmp;
            this.angle += this.wobbleSpeed;
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.velocity = {
                x: (Math.random() - 0.5) * 8,
                y: (Math.random() - 0.5) * 8
            };
            this.alpha = 1;
            this.friction = 0.95;
        }

        draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.restore();
        }

        update() {
            this.velocity.x *= this.friction;
            this.velocity.y *= this.friction;
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.alpha -= 0.02;
        }
    }
    
    class PowerUp {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.radius = 15;
            this.vy = 2;
            this.text = "P";
        }
        
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fillStyle = '#0f0';
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.text, this.x, this.y);
        }
        
        update() {
            this.y += this.vy;
        }
    }

    // --- GAME LOGIC ---

    function startGame() {
        gameRunning = true;
        score = 0;
        frame = 0;
        scoreEl.innerText = score;
        startScreen.style.display = 'none';
        
        player = new Player();
        projectiles = [];
        enemies = [];
        particles = [];
        powerups = [];
        
        animate();
    }
    
    function gameOver() {
        gameRunning = false;
        startScreen.style.display = 'block';
        document.querySelector('#start-screen h1').innerText = "GAME OVER";
        document.querySelector('#start-screen p').innerText = `Final Score: ${score}`;
        startBtn.innerText = "Try Again";
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function spawnEnemies() {
        if (frame % 60 === 0) {
            enemies.push(new Enemy());
        }
    }

    function animate() {
        if (!gameRunning) return;
        requestAnimationFrame(animate);
        frame++;

        // Clear Canvas with trail effect
        ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // Update Player
        player.update();
        player.draw();

        // Projectiles
        projectiles.forEach((p, index) => {
            p.update();
            p.draw();
            // Remove if off screen
            if (p.y < 0) projectiles.splice(index, 1);
        });

        // Particles
        particles.forEach((p, index) => {
            if (p.alpha <= 0) {
                particles.splice(index, 1);
            } else {
                p.update();
                p.draw();
            }
        });
        
        // Powerups
        powerups.forEach((p, index) => {
            p.update();
            p.draw();
            
            // Collision with player
            const dist = Math.hypot(player.x - p.x, player.y - p.y);
            if (dist < player.radius + p.radius) {
                player.gunLevel = Math.min(3, player.gunLevel + 1);
                score += 500;
                createExplosion(p.x, p.y, '#0f0');
                powerups.splice(index, 1);
            } else if (p.y > canvasHeight) {
                powerups.splice(index, 1);
            }
        });

        // Enemies
        spawnEnemies();
        enemies.forEach((enemy, eIndex) => {
            enemy.update();
            enemy.draw();

            // Projectile Collision
            projectiles.forEach((p, pIndex) => {
                const dist = Math.hypot(p.x - enemy.x, p.y - enemy.y);
                
                if (dist - enemy.radius - p.radius < 1) {
                    // Hit!
                    createExplosion(p.x, p.y, '#ff0');
                    projectiles.splice(pIndex, 1);
                    enemy.hp--;
                    
                    if (enemy.hp <= 0) {
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        
                        // Random Powerup chance
                        if (Math.random() > 0.9) {
                            powerups.push(new PowerUp(enemy.x, enemy.y));
                        }
                        
                        score += 100;
                        scoreEl.innerText = score;
                        enemies.splice(eIndex, 1);
                    }
                }
            });

            // Player Collision
            const distPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
            if (distPlayer - enemy.radius - player.radius < 1) {
                createExplosion(player.x, player.y, '#0ff');
                gameOver();
            }

            // Remove if off screen
            if (enemy.y > canvasHeight + 100) {
                enemies.splice(eIndex, 1);
            }
        });
        
        // Stars Background
        ctx.fillStyle = '#fff';
        if (Math.random() > 0.5) {
            const sx = Math.random() * canvasWidth;
            const sy = Math.random() * canvasHeight;
            const sSize = Math.random() * 2;
            ctx.fillRect(sx, sy, sSize, sSize);
        }
    }

</script>
</body>
</html>
